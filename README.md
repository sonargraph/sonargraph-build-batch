# sonargraph-build-batch
This code demonstrates how Sonargraph-Build, the headless version of [Sonargraph](https://www.hello2morrow.com/), can be executed for a series of different versions of a system.
The generated XML reports and snapshots are persisted to disk and uploaded to an instance of [Sonargraph-Enterprise](https://www.hello2morrow.com/products/sonargraph/enterprise), 
a repository of analysis results, where metric trends are displayed as graphs.

Of course, this analysis could also be implemented as a batch script. But debugging and error handling is so much easier using a proper
programming language...

There are currently two analysis implemented:
1. Class [com.hello2morrow.sonargraph.batch.analysis.CwaServerAnalysis](/src/main/java/com/hello2morrow/sonargraph/batch/analysis/CwaServerAnalysis.java) 
demonstrates how tagged commits are retrieved from a Git repo, individual commits are checked out, built with Maven and analyzed with Sonargraph.
2. If building past releases is too complicated and time consuming the class 
[com.hello2morrow.sonargraph.batch.analysis.AnalyzeMavenArtifact](/src/main/java/com/hello2morrow/sonargraph/batch/analysis/AnalyzeMavenArtifact.java) 
demonstrates how the available releases are retrieved from a Maven repository, the jar and sources-jar are downloaded, and used in a Sonargraph software system 
which is then analyzed using Sonargraph-Build.

If you want to run the analysis for a Maven module available on Maven Central, the following commandline shows how this can be done:
```
java -cp sonargraph-build-batch-1.1.0.jar com.hello2morrow.sonargraph.batch.analysis.AnalyzeMavenArtifact 
groupId=org.hibernate artifactId=hibernate-core propertyFileName=./src/main/resources/maven-central.properties activationCode=XXXX-XXXX-XXXX-XXXX
```

Additional configuration is done via properties files contained in [src/main/resources](/src/main/resources).

If you want to run one of the existing analysis or create your own, you need a license for Sonargraph-Build and a [Sonargraph-Enterprise installation](https://www.hello2morrow.com/products/sonargraph/enterprise).
An evaluation license can be requested at [https://www.hello2morrow.com/try_it](https://www.hello2morrow.com/try_it).
Of course, if you don't want to use Sonargraph-Enterprise, you can use our [Integration library](https://github.com/sonargraph/sonargraph-integration-access) to extract information from
the reports generated by Sonargraph-Build.

DISCLAMER: This is not a product! 
Therefore, it is not guaranteed that you only need to adapt the configuration properties and then the analysis runs flawlessly on your machine.
Take a look at the code, copy what makes sense to you and extend it where needed. Run the analysis in debug mode and step through the analysis of the initial versions.
It might be necessary to curate the list of versions. After you have done that, set 'writeVersionsFile=true' as argument, so that your work does not get overwritten.  

Further information about Sonargraph:
* [Homepage](https://www.hello2morrow.com/)
* [Sonargraph User Manual](https://eclipse.hello2morrow.com/doc/standalone/content/index.html)
* [Sonargraph-Build User Manual](http://eclipse.hello2morrow.com/doc/build/content/index.html)

## Some Sample Results
The results for some Maven artifacts are available on our public Sonargraph-Enterprise instance at [http://enterprise.hello2morrow.com:8080](http://enterprise.hello2morrow.com:8080).
Switch to profile 'Entanglement', select a system and switch to page 'Entanglement'. 

The analysis of a series of versions has been implemented to investigate how coupling and cyclic dependencies evolve over time together
with the size of the projects. The following are a screenshots of Sonargraph-Enterprise which has been configured to show metrics for the system's size 
and coupling. (Of course, all other System-level metrics computed by Sonargraph are also available and could be investigated.)

The state of Hibernate-Core ([Hibernate-Core](https://github.com/hibernate/hibernate-orm/tree/main/hibernate-core)) is pretty severe:
* 89% of all lines of code are contained in files involved in cycle groups.
* The biggest component cycle group contains 2,211 out of 3,538 source files, the biggest package cycle group contains 
  264 of 283 packages.
* Average Component Dependency is ~2188, meaning that on average a source file depends on 2187 other source files.
  
![Trend of Hibernate-Core](/doc/Hibernate-Core_Entanglement.png "Trend of Hibernate-Core")

![Trend of Biggest Component Cycle in Hiberante-Core](/doc/Hibernate-Core_Biggest-Component-Cycle.png "Trend of Biggest Component Cycle in Hibernate-Core")

The state of CWA-Server ([CWA-Server](https://github.com/corona-warn-app/cwa-server)) is better, but also shows growing 
metrics for code involved in cycles.
* 39% of all lines of code are contained in files involved in cycle groups. 
* Cycle groups are not yet huge, but constantly growing.

![Trend of CWA-Server](/doc/CWA-Server_Entanglement.png "Trend of CWA-Server")

![Trend of Biggest Component Cycle in CWA-Server](/doc/CWA-Server_Biggest-Component-Cycle.png "Trend of Biggest Component Cycle in CWA-Server")

Both analysis back-up our experience that if you don't monitor the system's structure and actively fight against the entropy, the problem will get more severe over time.
The end result is a ["Big Ball of Mud" ](http://www.laputan.org/mud/).

The best way to keep the system structure in a healthy state, is to constantly monitor and eliminate cycles when they are still small!